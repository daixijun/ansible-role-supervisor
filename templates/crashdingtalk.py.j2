#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

import argparse
import json
import socket
import sys
import os.path
import subprocess
from datetime import datetime

import requests
from supervisor import childutils

reload(sys)
sys.setdefaultencoding("utf-8")

DEFAULT_LINES = 10
MARKDOWN_TEMPLATE = """
### {title} \n\n
> 报警时间: {time} \n\n
> 主机名: {hostname} \n\n
> IP地址: {ip} \n\n
> 进程名: {processname} \n\n
> 进程组: {groupname} \n\n
最后10行错误日志: \n\n

```bash
{error_log}
```
"""


class CrashDingtalk(object):
    def __init__(self, parse_args, **kwargs):
        self.parse_args = parse_args
        self.stdin = sys.stdin
        self.stdout = sys.stdout
        self.stderr = sys.stderr
        self.white_events = [
            "PROCESS_STATE_EXITED",
            "PROCESS_STATE_STARTING",
            "PROCESS_STATE_RUNNING",
            "PROCESS_STATE_FATAL",
            "PROCESS_STATE_BACKOFF",
        ]
        self.flags = []

    def runforever(self):
        hostname = socket.gethostname()
        ip = socket.gethostbyname(hostname)
        while 1:
            headers, payload = childutils.listener.wait(self.stdin, self.stdout)

            eventname = headers["eventname"]
            if eventname not in self.white_events:
                # do nothing with non-TICK events
                childutils.listener.ok(self.stdout)
                continue

            pheaders, pdata = childutils.eventdata(payload + "\n")
            logfile = os.path.join(
                "{{ supervisor_log_dir }}",
                "{processname}.stderr.log".format(processname=pheaders["processname"]),
            )
            message = {}

            self.stderr.write("evnetname: " + eventname + "\n")
            self.stderr.flush()

            if eventname == "PROCESS_STATE_EXITED":
                # 过滤掉 expected 的 event, 仅处理 unexpected 的
                # 当 program 的退出码为对应配置中的 exitcodes 值时, expected=1; 否则为0
                if int(pheaders["expected"]):
                    childutils.listener.ok(self.stdout)
                    continue
                message["title"] = self.format_title("Supervisor 进程异常退出", "error")
                message["error_log"] = self.tail(logfile=logfile)
            elif eventname == "PROCESS_STATE_BACKOFF":
                # 进程启动失败
                message["title"] = self.format_title("Supervisor 进程启动失败", "error")
                message["error_log"] = self.tail(logfile=logfile)
            elif eventname == "PROCESS_STATE_FATAL":
                # 进程从运行状态转换为失败状态
                message["title"] = self.format_title("Supervisor 进程运行失败", "error")
                message["error_log"] = ""
            elif (
                eventname == "PROCESS_STATE_STARTING"
                and pheaders["from_state"] == "EXITED"
            ):
                # 只有当前正在启动并且上次状态为退出的信息，否则进程可能启动很多次都未能功，会造成大量报警信息
                # 同时将当前的进程名加入到队列中，当启动成功后从队列移除
                if pheaders["processname"] not in self.flags:
                    self.flags.append(pheaders["processname"])
                message["title"] = self.format_title("Supervisor 进程尝试重启", "warn")
                message["error_log"] = ""
            elif eventname == "PROCESS_STATE_RUNNING":
                # 只有进程之前有挂掉(在队列中)的进程才会发送恢复的报警信息
                if pheaders["processname"] not in self.flags:
                    childutils.listener.ok(self.stdout)
                    continue
                self.flags.remove(pheaders["processname"])
                message["title"] = self.format_title("Supervisor 进程重启成功")
                message["error_log"] = ""

            if message:
                message.update(
                    {
                        "hostname": hostname,
                        "ip": ip,
                        "processname": pheaders["processname"],
                        "groupname": pheaders["groupname"],
                        "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    }
                )
                payload = {
                    "msgtype": "markdown",
                    "markdown": {
                        "title": message["title"].encode("utf-8"),
                        "text": MARKDOWN_TEMPLATE.format(**message).encode("utf-8"),
                    },
                    "at": {
                        "atMobiles": self.parse_args.mobiles,
                        "isAtAll": self.parse_args.is_at_all,
                    },
                }

                self.send_dingtalk(payload)

            childutils.listener.ok(self.stdout)

    def format_title(self, msg, color="normal"):
        color_map = {"error": "#FF0000", "warn": "#EEEE00", "normal": "#3A5FCD"}
        return "<font color={color}>{msg}</font>".format(
            color=color_map[color], msg=msg
        )

    def tail(self, logfile, lines=DEFAULT_LINES):
        try:
            output = subprocess.check_output(["tail", "-n", str(lines), logfile])
            # lines = []
            # for index, line in enumerate(output.split("\n")):
            #     lines.append("{index}. {line}".format(index=index + 1, line=line))
            # output = ''.join(lines)
        except subprocess.CalledProcessError:
            output = ""
        return output

    def send_dingtalk(self, payload):
        dingtalk_url = "https://oapi.dingtalk.com/robot/send?access_token="
        headers = {"Content-Type": "application/json"}
        r = requests.post(
            dingtalk_url + self.parse_args.access_token,
            data=json.dumps(payload),
            headers=headers,
        )

        try:
            ret_data = r.json()
            if int(ret_data["errcode"]):
                error_message = "发送报警到钉钉失败，返回结果: {text}\n".format(
                    text=ret_data["errmsg"]
                )
            error_message = "发送报警到钉钉成功，payload: {payload!r}\n".format(payload=payload)
        except Exception, error:  # noqa
            error_message = "发送报警到钉钉失败，异常信息: {error}\n".format(error=str(error))
        finally:
            self.stderr.write(error_message.encode("utf-8"))  # noqa
            self.stderr.flush()


def parse_args():
    parser = argparse.ArgumentParser(description="Supervisor 进程监控并发送报警到钉钉群.")
    parser.add_argument(
        "-t",
        "--access_token",
        dest="access_token",
        required=True,
        type=str,
        help="钉钉群机器人的access_token",
    )
    parser.add_argument(
        "-m", "--mobiles", dest="mobiles", nargs="+", type=str, help="需要@的群员手机号"
    )
    parser.add_argument(
        "-a", "--all", dest="is_at_all", action="store_true", help="是否需要@所有人"
    )
    args = parser.parse_args()
    return args


if __name__ == "__main__":
    prog = CrashDingtalk(parse_args())
    prog.runforever()
